[{"fields": {"published_on": "2014-06-16", "author": 1, "title": "Basic Django part I", "content": "<p>This post series is a basic introduction to Django and how to combine it with <a href=\"http://openshift.com/\">Openshift</a> in order to have an online site. Before you start reading, I recommend following the <a href=\"https://docs.djangoproject.com/en/1.6/intro/tutorial01/\" target=\"blank\">tutorial</a> that djangoproject itself provides which will be more detailed than this post.</p>\r\n\r\n<p>First of all, you need to have Django installed. You can check how to install it in the <a href=\"/posts/1#gettingstarted\">first post</a> at step 2.</p>\r\n\r\n<p>Once you have it installed, go to the folder you work on your projects, and execute <code>django-admin startproject &lt;projectname&gt;</code>. Once executed, you will find the following structure:</p>\r\n\r\n<pre>\r\nprojectname\r\n|--manage.py\r\n|--projectname\r\n   |--__init__.py\r\n   |-- settings.py\r\n   |-- urls.py\r\n   |-- wsgi.py\r\n</pre>\r\n\r\n<ul>\r\n<li><b>manage.py</b>. Management file for your project. It can synchronize your database, start the development server, start an interactive shell and more. Execute <code>python manage.py -h</code> for a full list of available commands. You can also read the <a href=\"https://docs.djangoproject.com/en/dev/ref/django-admin/\">django manage.py</a> guide.</li>\r\n<li><b>settings.py</b>. Configuration file for your project. It is a python module (so you can do whatever you want in python). It contains variables that specify installed apps in your project (explained later), where to find the database, where to find static files (css, js, etc.), and more. This file will appear in almost all the posts because it is one of the most (or the most) important files in your project.</li>\r\n<li><b>urls.py</b>. Defines the routes of your project. Basically, it links the urls with your programmed functions, called views.</li>\r\n<li><b>wsgi.py</b>. Script for project deployment.</li>\r\n</ul>\r\n\r\n<p>Okay, so now, we know more or less the basic structure of a recently created Django project. If we now execute <code>python manage.py runserver</code> we will start the development server. If we open <a target=blank href=\"http://127.0.0.1:8000\">localhost:8000</a> we will see the welcome Django page.</p>\r\n\r\n<p>Welcome page is not so cute and does not provide any functionality, lets create a new app that will allow us to write posts. To do so, cd into the directory where <i>manage.py</i> is and execute <code>python manage.py startapp posts</code>. This will create a new folder called posts with the following files within it:</p>\r\n\r\n<ul>\r\n<li><b>models.py</b>. Here you define your models using python classes. Those models are directly bind to database tables. For example, for our post model we can use the following:\r\n\r\n<pre class=\"python\">\r\nfrom django.db import models\r\nfrom django.contrib.auth.models import User\r\n\r\nclass Post(models.Model):\r\n    title = models.CharField(max_length=200)\r\n    published_on = models.DateField(auto_now_add=True)\r\n    published = models.BooleanField(default=False)\r\n    author = models.ForeignKey(User)\r\n    tags = models.CharField(max_length=500, blank=True, null=True)\r\n    content = models.TextField()\r\n\r\n    commit = models.CharField(max_length=30, blank=True, null=True)\r\n    branch = models.URLField(max_length=150, blank=True, null=True)\r\n    tag = models.URLField(max_length=150, blank=True, null=True)\r\n\r\n    def __unicode__(self):    #Print object's title when printing the object\r\n        return self.title\r\n\r\n    def get_absolute_url(self):  #Return the url of the object\r\n        return \"/posts/%d\" % self.id\r\n\r\n    class Meta:    #Order by published_on field (newest first)\r\n        ordering = [\"-published_on\", ]\r\n</pre>\r\n\r\n<p>Now that we got our new app created and the data model defined, we need to register it as an app of our new project. Edit the variable <i>INSTALLED_APPS</i> inside the <i>settings.py</i> file and add <i>posts</i> in the end. Save it and execute <code>python manage.py syncdb</code>. If it's the first time you execute it for your project, it will ask to create a superuser for your project. Say yes and enter the username and password. If you didn't create it the first time, execute <code>python manage.py createsuperuser</code>. Once done, it will create the table <i>posts_post</i> with all the fields you specified during model definition. Pretty easy and clear right?</p>\r\n</li>\r\n\r\n<li><b>views.py</b>. Here you define functions that will provide the data that will be shown to the user using html templates. So, for example, if we want to show a list of posts and posts individually, we will create two view functions. First will return all the posts (filtered by attribute, for example, if published is True) and second will return a Post object which will be selected from the url the client accesses.\r\n\r\n<pre class=\"python\">\r\nfrom django.shortcuts import render, get_object_or_404\r\n\r\nfrom models import Post\r\n\r\n\r\ndef list(request):\r\n    data = {'posts': Post.objects.filter(published=True)}\r\n\r\n    return render(request, 'posts_list.html', data)\r\n\r\ndef detail(request, pk):\r\n    data = {'post': get_object_or_404(Post, pk=pk)}\r\n\r\n    return render(request, 'posts_detail.html', data)\r\n</pre>\r\n</li>\r\n\r\n<li><b>admin.py</b>. Controls what is displayed in the admin interface about the model. Yes, Django has an admin interface by default which can be used to add, modify and remove objects. You can access it at <a href=\"http://127.0.0.1:8000/admin\">localhost:8000/admin</a> (you need your development server running). If you enter you will see that posts are not listed there. To do so, the <i>admin.py</i> file should look like this:\r\n\r\n<pre class=\"python\">\r\nfrom django.contrib import admin\r\nfrom models import Post\r\n\r\nadmin.site.register(Post)\r\n</pre>\r\n\r\n<p>Now you can navigate to the <a href=\"http://127.0.0.1:8000/admin\">admin interface</a> and check that the posts app appears. Try to create new posts, delete them, etc.<p>\r\n</li>\r\n\r\n</ul>\r\n\r\n<p>Okay, so now we got our defined model registered with the admin interface and we can add new Post objects and work with them. We also have two view functions to retrieve individual Posts or list them. Now, we will create our html templates to use this view functions so we can show them to our readers:</p>\r\n\r\n<ol>\r\n<li> Edit the urls.py file and add the following lines before the <code>url(r'^admin/', include(admin.site.urls)),</code> line to link /posts/ and /posts/{id} urls to our view functions:\r\n<pre class=\"python\">\r\n    url(r'^posts$', 'posts.views.list', name='posts_list'),\r\n    url(r'^posts/(?P&lt;pk&gt;[\\w-]+)$', 'posts.views.detail', name='posts_detail'),\r\n</pre>\r\n\r\n<p>The syntax is very easy. First arg is the regular expression for our url, second is the view function we want to call and third is a unique name for the url, this allows us to call the url from html code with the <code>{% url posts_list %}</code> line.</p>\r\n\r\n<p> If we now try to access <a target=blank href=\"http://127.0.0.1:8000/posts\">/posts</a> it will raise an error saying that the template <i>posts_list.html</i> does not exist. If you remember, in the views.py from the posts app, the return line for every view specifies which template it should use to render the data we send back to the client.</p>\r\n</li>\r\n<li> Let's create the needed templates. Create a new folder inside the posts app called <i>templates</i>. Inside it, create both the <i>posts_detail.html</i> and the <i>posts_list.html</i> files:\r\n\r\n<pre class=\"django\">\r\n&lt;p&gt;\r\n  &lt;h3&gt;&lt;a href=&quot;/posts/{{post.id}}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/h3&gt;\r\n  &lt;p&gt;&lt;i&gt;{{ post.published_on }}&lt;/i&gt; by {{ post.author }}&lt;/p&gt;\r\n  &lt;p&gt;{% if post.tags %}Tags: {{ post.tags }}{% endif %}&lt;/p&gt;\r\n  &lt;p&gt;{% if post.commit %}Commit: &lt;a href=&quot;https://github.com/argaen/djangozone/tree/{{ post.commit }}&quot; target=blank&gt;{{ post.commit }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n  &lt;p&gt;{% if post.branch %}Branch: &lt;a href=&quot;https://github.com/argaen/djangozone/tree/{{ post.branch }}&quot; target=blank&gt;{{ post.branch }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n  &lt;p&gt;{% if post.tag %} Tag: &lt;a href={{ post.tag }} target=blank&gt;{{ post.tag }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n&lt;/p&gt;\r\n&lt;div class=&quot;post-content&quot;&gt;\r\n  &lt;p&gt;{{ post.content|safe }}&lt;/p&gt;\r\n&lt;/div&gt;\r\n&lt;hr style=&quot;margin-bottom:40px;&quot;&gt;\r\n</pre>\r\n\r\n<pre class=\"django\">\r\n{% for post in posts %}\r\n  &lt;p&gt;\r\n    &lt;h3&gt;&lt;a href=&quot;/posts/{{post.id}}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/h3&gt;\r\n    &lt;p&gt;&lt;i&gt;{{ post.published_on }}&lt;/i&gt; by {{ post.author }}&lt;/p&gt;\r\n    &lt;p&gt;{% if post.tags %}Tags: {{ post.tags }}{% endif %}&lt;/p&gt;\r\n    &lt;p&gt;{% if post.commit %}Commit: &lt;a href=&quot;https://github.com/argaen/djangozone/tree/{{ post.commit }}&quot; target=blank&gt;{{ post.commit }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n    &lt;p&gt;{% if post.branch %}Branch: &lt;a href=&quot;https://github.com/argaen/djangozone/tree/{{ post.branch }}&quot; target=blank&gt;{{ post.branch }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n    &lt;p&gt;{% if post.tag %} Tag: &lt;a href={{ post.tag }} target=blank&gt;{{ post.tag }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n  &lt;/p&gt;\r\n  &lt;div class=&quot;post-content&quot;&gt;\r\n    &lt;p&gt;{{ post.content|safe }}&lt;/p&gt;\r\n  &lt;/div&gt;\r\n  &lt;hr style=&quot;margin-bottom:40px;&quot;&gt;\r\n{% endfor %}\r\n</pre>\r\n\r\n<p>The syntax for the template rendering is very similar to jinja and angularjs. If you refresh now the browser, you will see your posts in a very ugly format (in next post I'll show briefly how to connect templates with css and js files). If it still shows the same error, reload the server. If you see nothing, create some posts using the admin interface and make sure you've marked the published tick!.</p>\r\n</li>\r\n</ol>\r\n\r\n\r\n<p> That's all for this post, next post will refactor the code to follow an structure that <a href=\"http://openshift.com/\" target=blank>Openshift</a> can understand so we can push our code to the service and have it working online! The last post (3rd) will also add some styling among other things in order to catch up the status of the blog you are seeing right now.</p>", "branch": "", "published": true, "keywords": "Django, admin, templates, models, views, urls", "commit": "", "slug": "basic-django-part-i"}, "model": "djzone_blog.post", "pk": 1}, {"fields": {"published_on": "2014-06-18", "author": 1, "title": "Basic Django part II (Openshift refactor)", "content": "<p>This post is a continuation of the <a target=blank href=\"/posts/2\">previous one</a>. In this one, you will refactor your basic Django project to support <a href=\"http://openshift.com\" target=blank>Openshift</a> project structure. Doing this, you will be able to have an online site working on their gears.</p>\r\n<p>Let's recall the project structure we got till now:</p>\r\n<pre>\r\nprojectname\r\n|--manage.py\r\n|--projectname\r\n   |--__init__.py\r\n   |-- settings.py\r\n   |-- urls.py\r\n   |-- wsgi.py\r\n|--posts\r\n   |--__init__.py\r\n   |--admin.py\r\n   |--models.py\r\n   |--tests.py\r\n   |--views.py\r\n   |--templates\r\n      |--posts_detail.html\r\n      |--posts_list.html\r\n|--db.sqlite3\r\n</pre>\r\n\r\n<p>Before you start, create a new <a href=https://www.openshift.com/app/account/new target=blank>Openshift</a> account and once you are registered, create a new application selecting the Django application type. I usually select python2.7 in the cartridges section. Click in <i>create application</i> (this may take a while). Once finished, click on <i>Yes, help me get started</i> and upload your public ssh key. If you don't have one, execute <code>ssh-keygen</code> and accept all default values. When you finish, copy the contents of <i>~/.ssh/id_rsa.pub</i> and save. Clone the project following the steps they show you (<code>git clone</code>). Once downloaded, cd into the project folder and execute <code>rm *</code>.</p> \r\n\r\n<p>So, now yes, let's start:</p>\r\n\r\n<ol>\r\n\r\n<li>Create the following directory structure inside the downloaded folder of your Openshift app:\r\n<pre>\r\n|--projectname (this folder is the project folder you've just cloned with git, it is already created. I'll call it djangozone from now on)\r\n   |--setup.py\r\n   |--wsgi.py\r\n   |--wsgi\r\n      |--static\r\n      |--djangozone\r\n         |--__init__.py\r\n</pre>\r\n </li>\r\n\r\n<li>Copy the files <i>manage.py</i>, <i>settings.py</i>, <i>urls.py</i> and <i>db.sqlite3</i> and the <i>posts</i> app to <i>djangozone/wsgi/djangozone</i> folder of the new project.</li>\r\n\r\n<li>In <i>settings.py</i> remove the line that sets the <i>WSGI_APPLICATION</i> variable. Change the \"ROOT_URLCONF = projectname.urls\" to \"ROOT_URLCONF = urls\".</li>\r\n\r\n<li>In <i>manage.py</i> change the line <code>os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"projectname.settings\")</code> to <code>os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"settings\")</code></li>\r\n\r\n<li>Edit the <i>djangozone/wsgi.py</i> and set the content equal to the file you can find in <a href=\"https://github.com/argaen/djangozone/blob/development/wsgi.py\" target=blank>github</a></li>\r\n\r\n<li>Edit the <i>djangozone/setup.py</i> and set the content equal to the file you can find in <a href=\"https://github.com/argaen/djangozone/blob/development/setup.py\" target=blank>github</a></li>\r\n\r\n<li>Edit the <i>settings.py</i> and add the line <code>STATIC_ROOT = os.path.join(BASE_DIR, '../static')</code> under the <i>STATIC_URL</i> variable. Also change the line <i>BASE_DIR = os.path.dirname(os.path.dirname(__file__))</i> to <i>BASE_DIR = os.path.dirname(os.path.realpath(__file__)).</i></li>\r\n\r\n<li>Also, in <i>settings.py</i> file, remove the <i>DEBUG=True</i> and <i>ALLOWED_HOSTS=[]</i> and put this (we don't want DEBUG mode in production):\r\n<pre class=\"python\">\r\nON_OPENSHIFT = False\r\nif 'OPENSHIFT_REPO_DIR' in os.environ:\r\n    ON_OPENSHIFT = True\r\n\r\nif ON_OPENSHIFT:\r\n    DEBUG = False\r\n    ALLOWED_HOSTS = ['*']\r\nelse:\r\n    DEBUG = True\r\n    ALLOWED_HOSTS = []\r\n</pre>\r\n</li>\r\n\r\n</ol>\r\n\r\n<p>Time to upload the project to <a href=\"http://openshift.com\">Openshift</a>!. Let's apply the changes and upload them. Do <code>git add -A .;git commit -m \"Initial commit\";git push</code> from the root of the project and let Openshift do the magic of deploying your project automatically! Once uploaded, access the url of your application (applications section in the Openshift page). It will show a page not found error, this is because we have no welcome page, access directly to /posts and it should show a blank page (if you had a post already created from part 1 post, it should appear because you copied the db.sqlite3 file). So, now it's time to create a new post by accessing the /admin page. You will see that the admin page is so ugly, this is because the static files where not collected (now we are running our app using a web server which does not know where to find those files, we have to place them all in the <i>djangozone/wsgi/static</i> folder). To do so, we can use the Openshift <a target=blank href=\"https://www.openshift.com/developers/deploying-and-building-applications#build\">action hooks</a> to collect all the files automatically every time we do a deploy:</p>\r\n\r\n<ol>\r\n<li>If you cloned the git repo from your Openshift application, you should have a <i>djangozone/.openshift/action_hooks</i> folder. cd into it.</li>\r\n<li>Create a file called <i>deploy</i> with the following inside:\r\n<pre class=\"bash\">\r\n#!/bin/bash\r\n\r\necho \"Executing 'python $OPENSHIFT_REPO_DIR/wsgi/djangozone/manage.py collectstatic --noinput'\"\r\npython \"$OPENSHIFT_REPO_DIR\"wsgi/djangozone/manage.py collectstatic --noinput\r\n</pre>\r\n</li>\r\n<li> Do <code>git add -A .;git commit -m \"Static files configuration\";git push</code> and when it finishes, you should see the same page as when running in local.</li>\r\n\r\n</ol>\r\n\r\n<p>Right now, you have the same app running in Openshift online and in your local environment. You can try to add new posts and read them in your online instance.</p>\r\n\r\n<p>Still, the site has no styling, soon I'll post how templates work and how to load external css and js files. If you can't wait, check the files under <i>posts/templates</i> and this <a target=blank href=\"https://docs.djangoproject.com/en/dev/howto/static-files/\">page</a>.</p>\r\n\r\n<p>We are not in the same version that <a href=http://django.zone>django.zone</a> is running at yet. In the next post, I will show how templates, urls and some configuration settings work in order to catch up the current version!</p>\r\n\r\n\r\n\r\n\r\n\r\n", "branch": "", "published": true, "keywords": "Django, migrating to Openshift, openshift", "commit": "", "slug": "basic-django-part-ii-openshift-refactor"}, "model": "djzone_blog.post", "pk": 2}, {"fields": {"published_on": "2014-06-25", "author": 1, "title": "Basic Django part III", "content": "<p>This post is a continuation of the <a target=blank href=\"/posts/3\">previous one</a>. In this one, we will a add some styling to our using django templates, static files and <a href=\"http://getbootstrap.com/\" target=blank>twitter bootstrap</a> and how to use a decent database backend (postgresql) in Openshift to save our posts. We will also do some minor modifications to make our code cleaner.</p>\r\n\r\n<h4>Templates</h4>\r\n\r\n<p>We will start by creating an app called common to save all the stuff not related to our content apps. Do <code>python manage.py startapp common</code> and register it in the settings file (<i>INSTALLED_APPS</i>) variable. Create a <i>templates</i> folder within the <i>common</i> app and the files <i>base.html</i> and <i>about.html</i> (yeah, we are creating an about page) within this folder. Copy the contents you can find in the github <a href=\"https://github.com/argaen/djangozone/blob/development/wsgi/openshift/common/templates/base.html\" target=blank>base.html</a> and <a href=\"https://github.com/argaen/djangozone/blob/development/wsgi/openshift/common/templates/about.html\">about.html</a> files to the files you've just created.</p>\r\n\r\n<p>If you open the <i>base.html</i> file, you will see that it looks like a common html (just FYI, I will not explain html, css and so on...) file except for some lines like <code>{% load staticfiles %}</code>. These lines, are rendered by the Django template system. For example, this one asks to load the <i>staticfiles</i> module, once you've loadded this module, you can ask for static files as you can see in lines 60-63 (i.e. {% static \"img/logos/django.png\" %}) were we load the icons of the <i>Powered by</i> section. You can also find the <code>{% block content %}</code> at line 54. This allows us to define blocks for other templates that will inherit from this one. To understand this, let's open the <i>about.html</i> file.</p>\r\n\r\n<p>In the <i>about.html</i> file you can find the <code>{% extends 'base.html' %}</code> line that specifies as you can guess, that this template is inheriting from <i>base.html</i>. Because of that, we can overwrite the blocks specified in that file:</p>\r\n\r\n<pre class=\"django\">\r\n{% block content %}\r\n&lt;Content goes here&gt;\r\n{% endblock %}\r\n</pre>\r\n\r\n<p>With that, we avoid to rewrite the common parts of the template (such as footer, header, etc.).</p>\r\n\r\n<p>Let's check how this looks like. Open the <i>urls.py</i> file and write the line <code>url(r'^about/$', 'common.views.about', name='about'),</code>. Also, in the <i>common/views.py</i> file, and write the following:</p>\r\n<pre class=\"python\">\r\nfrom django.shortcuts import render_to_response\r\n \r\ndef about(request):\r\n    return render_to_response('about.html')\r\n</pre>\r\n\r\n<p>If you now try to access <a href=http://localhost:8000/about>/about</a> and you will see that something appears. All images and some styling are missing. This is because we don't the required static files. Although, bootstrap styles are correctly loaded because we are using a <i>cdn</i>. We are done explaining templates, modify the templates of the posts app to inherit from the <i>base.html</i> file. You can find the original files in <a target=blank href=https://github.com/argaen/djangozone/tree/development/wsgi/openshift/posts/templates>github</a>. Now that we got our templates, it's time to load our static content correctly.</p>\r\n\r\n<h4>Static Files</h4>\r\n\r\n<p>Static files are those files which are static (O RLY?) like images, css spreadsheets, javascripts and so on. By default, to load those files, in debug mode Django looks within a folder called <i>static</i> of all the installed apps of your project. If you now specify <code>DEBUG=False</code> in your <i>settings.py</i> file and try to access to the <a href=\"http://localhost:8000/admin\">admin</a> page, you will see that all styles are missing. To make it work, you need to execute <code>python manage.py collectstatic</code> you will see that a folder called <i>admin</i> appears within <i>djangozone/wsgi/static</i>. The same applies for our apps. Let's create the <i>static</i> folder for the <i>common</i> app. You can download all the contents from <a target=blank href=\"https://github.com/argaen/djangozone/tree/development/wsgi/openshift/common/static\">github</a>. Set <code>DEBUG=True</code> again in your <i>settings</i> file and reload your site. <i>Voil\u00e0!</i> now our blog starts looking not so ugly at all. When pushing our project to Openshift, it will work in deploy mode but collectstatic will be executed automatically because we defined the deploy action hook in previous post so you don't have to worry about static files anymore (as long as you place static files inside the static folder of your pertinent apps).</p>\r\n\r\n\r\n<h4>Urls</h4>\r\n\r\n<p>We want to have an organized project. The <i>urls</i> can be distributed among different apps (more or less like static files, templates). In the main <i>urls.py</i> file we have urls defined for our posts app and this is not correct at all. Create a file called <i>urls.py</i> within the <i>posts</i> app with this content:</p>\r\n<pre class=\"python\">\r\nfrom django.conf.urls import patterns, url\r\n\r\nurlpatterns = patterns(\r\n   'posts.view',\r\n   url(r'^$', 'list', name='posts_list'),\r\n   url(r'^(?P<pk>[\\w-]+)$', 'detail', name='posts_detail'),\r\n)\r\n</pre>\r\n\r\n<p>In the main <i>urls.py</i> file, remove the lines related to <i>posts</i> app and add these lines:</p>\r\n<pre>\r\nurl(r'^$', 'posts.views.list', name='posts_list'),\r\nurl(r'^posts/', include('posts.urls')),\r\n</pre>\r\n\r\n<p>With the first, we specify home page to display all the posts. With the second, we include the urls defined in the <i>posts</i> app.\r\n\r\n<h4>Postgres and Openshift</h4>\r\n\r\nSqlite isn't a database for production. To use Postgres, we need first to create the instance (cartridge) in our Openshift. To do so, access to your <a target=blank href=https://openshift.redhat.com/app/console/applications>applications</a> and click in your application. Click on 'add postgresql 9.2'. Once completed, it will display your acess data but don't worry, we don't need it. Open the <i>settings</i> file and remove the <i>DATABASES</i> dictionary and write these lines:\r\n\r\n<pre class=\"python\">\r\nif ON_OPENSHIFT:\r\n    url = urlparse.urlparse(os.environ.get('OPENSHIFT_POSTGRESQL_DB_URL'))\r\n    DATABASES = {\r\n        'default': {\r\n            'ENGINE': 'django.db.backends.postgresql_psycopg2',\r\n            'NAME': os.environ['OPENSHIFT_APP_NAME'],\r\n            'USER': url.username,\r\n            'PASSWORD': url.password,\r\n            'HOST': url.hostname,\r\n            'PORT': url.port,\r\n            }\r\n        }\r\n\r\nelse:\r\n    DATABASES = {\r\n        'default': {\r\n            'ENGINE': 'django.db.backends.sqlite3',\r\n            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),\r\n        }\r\n    }\r\n</pre>\r\n\r\nWrite <code>import urlparse</code> at the top of <i>settings.py</i> file. We are ready to deploy our blog! Add your changes, commit and push!", "branch": "", "published": true, "keywords": "Django, bootstrap, openshift, staticfiles, templates ", "commit": "", "slug": "basic-django-part-iii"}, "model": "djzone_blog.post", "pk": 3}, {"fields": {"published_on": "2014-07-02", "author": 1, "title": "Using django-taggit", "content": "<p>In this post I will show how to use tags correctly for our posts. Taggit allows to search among our posts by tag, search posts with similar tags and more. You can check its documentation <a href=\"http://django-taggit.readthedocs.org/en/latest/\">here</a>.</p>\r\n\r\n<p>Let's do this. Install the package with <code>pip install django-taggit</code> and register it in <i>INSTALLED_APPS</i> inside your <i>settings.py</i> file (app name is <i>taggit</i>. Once done, run <code>python manage.py syncdb</code> to create the tag tables in your database. Now, for each model you want to add a tag (posts in our case), create a new field like this: <code>tags = TaggableManager(blank=True)</code>. You can import <i>TaggableManager</i> with <code>from taggit.managers import TaggableManager</code>.</p>\r\n\r\n<p>After this, we can go to our <a target=blank href=\"http://localhost:8000/admin\">admin</a> interface, edit a post and add tags as comma separated words. After saving, if we try to refresh, it will display the object instance rather than the tags. This is because in the posts template we have <code>{{post.tags}}</code>. Write these lines to display the tags:</p>\r\n\r\n<pre class=\"django\">\r\n      {% if post.tags %}&lt;p&gt;Tags: \r\n        {% for tag in post.tags.all %}\r\n          &lt;a href=\"/posts/tag/{{ tag }}\"&gt;{{tag}}&lt;/a&gt;\r\n        {% if not forloop.last %},{% endif%}\r\n        {% endfor %}\r\n      &lt;/p&gt;{% endif %}\r\n</pre>\r\n\r\n<p>We also need to add a line to the <i>urls.py</i> for our posts app: <code>url(r'^tag/(?P<tag>\\w+)$', 'tags', name='posts_tags'),</code> and create a new view in <i>views.py</i> to display the posts with the given tags:</p>\r\n\r\n<pre class=\"python\">\r\ndef tags(request, tag):\r\n    data = {'posts': Post.objects.filter(tags__name__in=[tag])}\r\n\r\n    return render(request, 'posts_list.html', data)\r\n</pre>\r\n\r\n\r\n<p>It is also interesting when reading a post, to display the ones with similar tags. We can do this so easily. To do so, we need to modify our detail template by adding these lines:</p>\r\n<pre class=\"django\">\r\n  {% if post.tags.similar_objects %}\r\n    Similar: \r\n    {% for s in post.tags.similar_objects|slice:\":3\" %}\r\n      &lt;a href={% url 'posts_detail' s.id %}&gt;{{s}}&lt;/a&gt;\r\n    {% if not forloop.last %},{% endif%}\r\n    {% endfor %}\r\n  {% endif %}\r\n</pre>\r\n\r\n<p> With this, code, we are showing the three most similar (in tags) posts being the first the most similar one.</p> ", "branch": "", "published": false, "keywords": "Django, taggit, tags, tagging content", "commit": "", "slug": "using-django-taggit"}, "model": "djzone_blog.post", "pk": 4}, {"fields": {"published_on": "2014-07-09", "author": 1, "title": "Adding disqus comments to your posts", "content": "<h4>Basic configuration</h4>\r\n\r\n<p>In previous versions, Django provided a comments framework in the <i>contrib</i> packages but now is deprecated so I will be using <i>disqus</i>. To integrate it with Django I could use the <i>django-disqus</i> but I won't. I'll integrate it with raw code because in the next post I'll write about templatetags which is what <i>django-disqus</i> uses so then, you can move to use this package understanding what you are really doing.</p>\r\n\r\n<p>First of all, we need to create a disqus <a href=\"https://disqus.com/profile/signup/?next=https%3A//disqus.com/\" target=blank>account</a>. Once created, <a href=http://disqus.com/admin/create/ target=blank>register</a> a new app. When you finish the registration, choose the \"Universal Code\" platform choice and paste the code it displays where you want the comments to appear. In my case, I'll use the <i>posts_detail.html</i> template.</p>\r\n\r\n<pre class=\"html\">\r\n&lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */\r\n    var disqus_shortname = \"SHORT_NAME\"; // required: replace example with your forum shortname\r\n    /* * * DON'T EDIT BELOW THIS LINE * * */\r\n    (function() {<br/>            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\r\n         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';<br/>            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\r\n    })();\r\n&lt;/script&gt;\r\n&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;\r\n&lt;a href=&quot;http://disqus.com&quot; class=&quot;dsq-brlink&quot;&gt;comments powered by &lt;span class=&quot;logo-disqus&quot;&gt;Disqus&lt;/span&gt;&lt;/a&gt;\r\n</pre>\r\n\r\n<p>Replace SHORT_NAME with your disqus app name you've just created. If you now refresh your page, it should appear a form that users can use to comment.</p>\r\n\r\n<p>Within the <a href=http://disqus.com/admin target=blank>disqus admin</a> page you can perform further configurations for comment moderation, control who can comment, minor template modifications and more.</p>\r\n\r\n<p>That's all, we got now functional comments for our posts. In next section I will show <a href=#recentcomments>how to create a section that shows recent comments</a>.</p>\r\n\r\n<h4 id=recentcomments>Recent Comments</h4>\r\n\r\nTo show recent comments, disqus also provides a javascript code similar to the one used to retrieve comments for a post. If you want to display recent comments, you can use this code:\r\n\r\n<pre class=\"html\">\r\n&lt;div class=&quot;panel panel-primary&quot;&gt;\r\n  &lt;div class=&quot;panel-heading&quot;&gt;\r\n    &lt;h4&gt;Recent Comments&lt;/h4&gt;\r\n  &lt;/div&gt;<br/>\r\n  &lt;div id=&quot;RecentComments&quot; class=&quot;dsq-widget panel-body&quot;&gt;\r\n  &lt;script type=&quot;text/javascript&quot; src=&quot;http://djangozone.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_mods=0&amp;hide_avatars=0&amp;avatar_size=32&amp;excerpt_length=100&quot;&gt;&lt;/script&gt;\r\n  &lt;/div&gt;\r\n&lt;/div&gt;\r\n</pre>\r\n\r\n<p>The following arguments allow you to customize the data that is shown:</p>\r\n\r\n<ul>\r\n<li><b>num_items</b>: Number of comments to return.</li>\r\n<li><b>hide_mods</b>: If 1, hide admin comments.</li>\r\n<li><b>hide_avatars</b>: If 1, hide user avatars.</li>\r\n<li><b>avatar_size</b>: Size of the avatar in px.</li>\r\n<li><b>excerpt_length</b>: Max length of the comments being displayed. They are truncated in chars.</li>\r\n</ul>\r\n\r\n", "branch": "", "published": true, "keywords": "Django, disqus, comments", "commit": "", "slug": "adding-disqus-comments-your-posts"}, "model": "djzone_blog.post", "pk": 5}, {"fields": {"published_on": "2014-07-30", "author": 1, "title": "Django templatetags", "content": "<p>Template tags are the core of Django templates providing well-known coding functionalities like loops (\"for\" tag), conditions (\"if\" tag) and more. You can check the full list in the <a href=\"https://docs.djangoproject.com/en/dev/ref/templates/builtins/\">djangoproject</a> page. While they are enough powerful to provide all the basic functionality you need in your projects, sometimes, just to follow the principle of DRY, it is worth it to implement some custom template tags.</p>\r\n\r\n<p>Let's see a very basic example. Here in DjangoZone we got a basic <a href=\"http://django.zone/contents/posts/basic-django-part-i\">Post model</a> that supports <a href=\"http://django.zone/posts/using-django-taggit\">tags</a> and <a href=\"http://django.zone/posts/adding-disqus-comments-to-your-posts\">disqus comments</a>. Now, we want people navigating and looking for cool Django tutorials to find our awesome posts. To do so, we will use the html meta-keyword in order to categorize our posts and make them appear in the right time. </p>\r\n\r\n<p>Why do we need templatetags then? Right now, we can obtain our post tags accessing the <code>{{ post.tags.all }}</code> variable from our <a href=\"https://github.com/argaen/djangozone/blob/master/wsgi/djangozone/posts/templates/posts_detail.html#L10\">posts_detail.html</a> template. You can see that we loop through all the tags creating an href element for each one. If we want to use post tags as our keywords, we will have to write again the loop to show all them as a comma separated list. That's the opportunity we seek to write a new tag.</p>\r\n\r\n<p>First, we both need the comma separated list and the list of href elements so, our template tag is going to have an argument to distinguish which functionality we need. Let's create it:</p>\r\n\r\n<ul>\r\n<li>First, create a \"templatetags\" folder within the posts app and cd into it. This is where Django looks for by default.</li>\r\n<li>Don't forget to create a \"__init__.py\" file so the folder is identified as a python module folder.</li>\r\n<li>Create the \"posts_tags.py\" file and write the following:</li>\r\n<pre class=\"python\">\r\nfrom django import template\r\n\r\nimport os\r\n\r\nregister = template.Library()\r\n\r\n@register.simple_tag                    #register this function as a callable tag\r\ndef get_tags(tags, url=None):\r\n    ret_tags = []\r\n    for tag in tags:\r\n        head = \"&lt;a href=%s&gt;#\" % os.path.join(url, tag) if url else ''\r\n        tail = \"&lt;/a&gt;\" if url else ''\r\n        ret_tags.append(head+str(tag)+tail)\r\n    return ', '.join(ret_tags)\r\n</pre>\r\n</li>\r\n<li> And now, in the template load the tag with <code>{% load posts_tags %}</code> and then call it where you need with <code>{% get_tags post.tags.names \"/posts/tags\" %}</code> if you need an href list where each link points to \"/posts/tags/&lt;tag_name&gt;\" or <code>{% get_tags post.tags.names %}</code> if you want the comma separated tags list.</li>\r\n<li> After reloading the page, you should see the meta keywords if you open the source code of the html and the tag list for the post should still be there. </li>\r\n</ul>\r\n\r\n<p>If you check the templatetags file in <a href=\"https://github.com/argaen/djangozone/blob/development/wsgi/djangozone/posts/templatetags/posts_tags.py\">github</a>, you can also check the function to retrieve the latest X posts where X is a parameter indicating how many posts you want to retrieve.</p>\r\n", "branch": "", "published": true, "keywords": "Django, templatetags, templatetags introduction", "commit": "", "slug": "django-templatetags"}, "model": "djzone_blog.post", "pk": 6}, {"fields": {"published_on": "2014-09-24", "author": 1, "title": "Code highlighting with pygments", "content": "<a target=blank href=http://pygments.org/>Pygments</a> is a generic syntax higlighter written in python that supports various <a target=blank href=\"http://pygments.org/languages/\">languages</a>. It is a very stable and awesome package so we will use it to highlight the code we show in our posts:\r\n\r\n<ul>\r\n<li> Install the package with <code>pip install pygments</code>. </li>\r\n<li> Create the css style using the command <code>pygmentize -S $THEME -f html > pygments-colorful.css</code> where $THEME is the theme you want to use for the syntax highlighting. We are using \"colorful\" but you can use any built-in style: \r\n\r\n<pre class=\"python\">\r\n>>> from pygments.styles import get_all_styles\r\n>>> styles = list(get_all_styles())\r\n</pre>\r\n</li>\r\n<li> Place the generated css file in the static folder (wsgi/djangozone/common/static/css in our case).</li>\r\n<li> Include it with <code>&lt;link rel=\"stylesheet\" type=\"text/css\" href={% static \"css/pygments-colorful.css\" %}&gt; </code>.</li>\r\n<li> Next step is to write a template filter (they are similar to  <a target=blank href=\"/contents/posts/django-templatetags\">templatetags</a>)  to apply the syntax highlighting to our content. We only want to highlight the content inside the \"pre\" tag. We will also set the class=\"$LANGUAGE\" so pygments can identify which language highlighter has to use. The template filter is the following:\r\n\r\n<pre class=\"python\">\r\nfrom bs4 import BeautifulSoup\r\nfrom django import template\r\nfrom django.template.defaultfilters import stringfilter\r\n\r\nfrom pygments import highlight\r\nfrom pygments.lexers import get_lexer_by_name\r\nfrom pygments.formatters.html import HtmlFormatter\r\n\r\nregister = template.Library()\r\n\r\n@register.filter    # Register the function as a filter\r\n@stringfilter       # Filter expects a string as input\r\ndef highlight_code(html):\r\n\r\n    soup = BeautifulSoup(unicode(html))     # Create beautiful soup object to access html objects\r\n    preblocks = soup.findAll('pre')\r\n\r\n    for pre in preblocks:\r\n\r\n        if pre.has_key('class'):    # Check if the pre tag has the class attribute\r\n\r\n            try:\r\n                code = ''.join([unicode(item) for item in pre.contents])\r\n                lexer = get_lexer_by_name(pre['class'][0])  # Get the class attribute value to identify the language\r\n                formatter = HtmlFormatter()\r\n                code_hl = highlight(code, lexer, formatter)\r\n                pre.contents = [BeautifulSoup(code_hl)]\r\n                pre.name = 'code'\r\n\r\n            except:\r\n                raise\r\n\r\n    return unicode(soup)\r\n\r\n</pre>\r\n</li>\r\n\r\n<li> Load the filter in the html template with <code> {% load highlights %} </li>\r\n<li> Apply it to the content that can contain code you want to highlight with <code> obj.content|highlight_code|safe </li>\r\n<li> Refresh the page and watch it working! (Don't forget to execute <code>python manage.py collectstatic</code> if you are in production).</li>\r\n\r\n</ul>", "branch": "", "published": true, "keywords": "Django, templatetags, pygments, filters, code highlighting, code, highlights", "commit": "", "slug": "code-highlighting-pygments"}, "model": "djzone_blog.post", "pk": 7}, {"fields": {"published_on": "2014-12-15", "author": 1, "title": "Django 1.7 migrations troubleshooting", "content": "Django 1.7 migrations allow you to change your models and migrate them to your database backend. Previously you could either use South or you had to apply the changes manually. For detailed information about migrations, you can check the [migrations Django doc](https://docs.djangoproject.com/en/1.7/topics/migrations/). This post will show how to deal with some problems you can find when you screw up some columns/tables.\r\n\r\n\r\n#### Unknown column 'col_id' in 'table' when applying migrate\r\n\r\nYou may find this error when you remove a column manually from your tables. After this, if you try to apply any change to that field (remove, alter), you will find this error because it is trying to modify a non existing column. In the case of alter, the solution is to modify the migrations file created from the `python manage.py makemigrations` command to add the field rather than altering it. Example of the alter migrations file:\r\n\r\n    # -*- coding: utf-8 -*-\r\n    from __future__ import unicode_literals\r\n  \r\n    from django.db import models, migrations\r\n\r\n    class Migration(migrations.Migration):\r\n  \r\n        dependencies = [\r\n          ('<app_name>', '<previous_migration>'),\r\n        ]\r\n \r\n        operations = [\r\n          migrations.AlterField(\r\n            model_name='<model_name>',\r\n            name='<column_name>',\r\n            field='<field_definition>',\r\n            preserve_default=True,\r\n          ),\r\n        ]\r\n    \r\n\r\nChange it to (note that `migrations.AlterField` has been changed to `migrations.AddField`):\r\n\r\n    # -*- coding: utf-8 -*-\r\n    from __future__ import unicode_literals\r\n  \r\n    from django.db import models, migrations\r\n\r\n    class Migration(migrations.Migration):\r\n  \r\n        dependencies = [\r\n          ('<app_name>', '<previous_migration>'),\r\n        ]\r\n \r\n        operations = [\r\n          migrations.AddField(\r\n            model_name='<model_name>',\r\n            name='<column_name>',\r\n            field='<field_definition>',\r\n            preserve_default=True,\r\n          ),\r\n        ]\r\n\r\nAfter this change, you can now use the `python manage.py migrate` to apply the migration.\r\n\r\n\r\n#### Duplicate column name 'column_id' or Can't DROP 'column_id'; check that column/key exists\r\n\r\nThis errors mean that you are trying to apply a migration that has been already applied. For the first, you are trying to add a column that already exists and in the second, you are trying to drop a column that already was dropped. In this cases, just use the `python manage.py migrate --fake` to fake the migration. With this, changes are not applied to the database. Only the migrations table is modified to tell that this migration is already applied.\r\n\r\nIn the first case, it could be that you are tying to add a column with the same name but what you wanted was to alter it. To fix it, modify the migrations file and change `migrations.AddField` to `migrations.AlterField` as we did in the first section (just the other way around).", "branch": "", "published": true, "keywords": "django 1.7, migrations, makemigrations, migrate", "commit": "", "slug": "django-17-migrations-troubleshooting"}, "model": "djzone_blog.post", "pk": 8}, {"fields": {"published_on": "2015-01-19", "author": 1, "title": "Importing Django models into a python script", "content": "Although Django is normally used as a framework to build web sites, thanks to its awesome ORM it can also be used to work with objects and databases that are not related to any public web. In other words, it can be used to give our desktop apps an easy to implement persistent storage. In my case, I want to develop an application that pulls data from an external service and stores it into a database for further analysis. The very easy steps to achieve this are:\r\n\r\n 1. Start a new Django project with `python manage.py startproject <yourproject>` and create a new app with `python manage.py startapp <yourapp>`.\r\n 2. Place it in the INSTALLED_APPS variable in your settings.py file.\r\n 3. Create your models under <yourapp>/models.py with the needed fields. Once done, do a `python manage.py syncdb` to create your database and the needed tables for your models. All previous points are the typical ones for creating new Django projects, you may want to change your database backend (by default it uses sqlite), the language or some other settings.\r\n 4. Next step is to create a script. It doesn't matter if it's inside your Django project or not, do it as you prefer.\r\n 5. Within this script, write the following lines:\r\n\r\n<pre class=\"python\">\r\nsys.path.append(\"/path/to/project\")\r\nos.environ[\"DJANGO_SETTINGS_MODULE\"] = \"&lt;project&gt;.settings\"\r\ndjango.setup()\r\n</pre>\r\n\r\nwhere '/path/to/project' is the absolute path to the root of your project. The root of your project is the folder that is created after executing `python manage.py startproject <yourproject>`. '<project>' is the folder inside the root of your project that contains the settings file so, if you called your project 'test', usually the structure will be:\r\n\r\n<pre class=\"bash\">\r\ntest\r\n-- test\r\n   -- settings.py\r\n   -- (urls.py, etc.)\r\n-- yourapp\r\n   -- (models.py, views.py, etc.)\r\n</pre>\r\n\r\nNow, you can import your models by doing `from yourapp.models import Mymodel` and start creating new instances, saving them to database, deleting, etc.\r\n\r\n\r\nDisclaimer: The code you write in this scripts has the same power as your views, or the code you execute with `python manage.py shell`, so be careful when removing content...", "branch": "", "published": true, "keywords": "using django models, outside project, django models without manage.py", "commit": "", "slug": "importing-django-models-python-script"}, "model": "djzone_blog.post", "pk": 9}, {"fields": {"published_on": "2015-01-24", "author": 1, "title": "Using virtualenvs for python", "content": "Virtualenv is a very useful tool that allows you to create virtual environments for python and install packages within them without the need to be root. This allows you to keep different virtualenvs to work with, isolating the dependencies for each project for example. It also allows you to test your project with different versions of its dependencies without breaking the system.\r\n\r\nTo install it, do a `sudo pip install virtualenv virtualenvwrapper`. Virtualenvwrapper is a tool that eases the usage of virtualenv. Once installed, we need to a couple of lines into our *~/.bashrc* file:\r\n\r\n<pre class=\"bash\">\r\nexport WORKON_HOME=$HOME/.virtualenvs  # Sets the directory for our virtualenvs to ~/.virtualenvs\r\nsource /usr/local/bin/virtualenvwrapper.sh        # Allows to call the commands like workon, mkvirtualenv, etc.\r\n</pre>\r\n\r\nFor the second line, the path may be different. To check it, just call `which virtualenvwrapper.sh` and check that the paths are the same, if it's not the case, change it for the one you get. After saving the file, close your current terminal and open it again, now you should be able to call the workon and mkvirtualenv commands.\r\n\r\nTo create your first virtualenv, call `mkvirtualenv testing`. After this, your command prompt will change indicating that you are within the *testing* virtualenv. If you now do a `pip freeze`, you will see that the package list is empty. Let's install the django package with `pip install django`, you will notice that it justs installs it without asking you any password. To exit from a virtualenv, just do a `deactive` and you will be again in the *system* environment.\r\n\r\nSo, the approach I use is to have a virtualenv for each project only with its dependencies (I try to keep my virtualenvs as clean as possible) and another for testing, just to install different versions of packages, new functionalities, etc.\r\n\r\nIf you need to erase a virtualenv, do a `rmvirtualenv <virtualenv_name>`.\r\n\r\n*Tip: The packages are installed under $WORKON_HOME/<virtualenv_name>/lib/python2.7/site-packages/*\r\n\r\n### Using virtualenvs in production with Django\r\n\r\nOkay, right now, you should be able to manage various virtualenvs, install and remove packages within them, delete virtualenvs, etc. How can we use the virtualenvs for production so we don't have to install the packages in our python system installation? All the configuration you need is within the **wsgi.py** file of your project. Usually, it contains lines to import your settings file and to activate the django app. To use the virtualenv *testing* you should have something like that:\r\n\r\n<pre class=\"python\">\r\n#!/usr/bin/env python\r\n\r\nimport os\r\nimport sys\r\n\r\nos.environ['DJANGO_SETTINGS_MODULE'] = '{my_project}.settings'\r\n\r\nsite.addsitedir('/home/{my_user}/.virtualenvs/testing/local/lib/python2.7/site-packages')\r\nactivate_env=os.path.expanduser(\"/home/{my_user}/.virtualenvs/testing/bin/activate_this.py\")\r\ntry:\r\n    execfile(virtualenv, dict(__file__=virtualenv))\r\nexcept:\r\n    pass\r\n\r\nfrom django.core.wsgi import get_wsgi_application\r\napplication = get_wsgi_application()\r\n</pre>\r\n\r\n\r\nChange {my_user} and {my_project} with the needed values. After restarting your web server (apache2, nginx or whatever), it should be using the packages in your virtualenv rather than the global ones.\r\n", "branch": "", "published": true, "keywords": "python, virtualenv, django packages virtualenv, virtualenvwrapper", "commit": "", "slug": "using-virtualenvs-python"}, "model": "djzone_blog.post", "pk": 10}, {"fields": {"published_on": "2015-01-20", "author": 1, "title": "Migrating any linux machine to another", "content": "This will work perfectly for you ...\r\n\r\nOn the source VM instance ...\r\n\r\nsudo su\r\ncd /\r\ntar cvpzf backup.tgz --exclude=/proc --exclude=/lost+found --exclude=/backup.tgz --exclude=/mnt --exclude=/sys /\r\nOn the target machine (dedicated or VPS)\r\n\r\ntar xvpfz backup.tgz -C /\r\nAnd make sure any dirs excluded are re-created\r\n\r\nmkdir proc\r\nmkdir lost+found\r\nmkdir mnt\r\nmkdir sys\r\n\r\nCare with fstab and /boot/grub/menu.lst\r\n", "branch": "", "published": false, "keywords": "linux, cloning machines", "commit": "", "slug": "migrating-any-linux-machine-another"}, "model": "djzone_blog.post", "pk": 11}, {"fields": {"published_on": "2014-12-03", "author": 1, "title": "Catalonia 9N Results", "content": "Interactive map with the results of the 9N consultation in Catalonia.", "template": "9n/9n.html", "published": true, "keywords": "catalonia, catalunya, 9n, eleccions, independencia, resultats2014, consulta independencia", "slug": "catalonia-9n-results"}, "model": "djzone_blog.project", "pk": 1}]