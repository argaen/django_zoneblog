[{"fields": {"published_on": "2014-06-13", "author": 1, "title": "Hello world, this is DjangoZone!", "content": "<p>I'm proud to introduce DjangoZone, a new blog which aim is to cover Django and its different awesome tools. Each post will cover topics like how to use Oauth, how to provide content using REST API, how to build a multilanguage app and more with code snippets. Best of all, is that those code snippets will come from the blog itself because it is open source. You can follow and download it at <a target=blank href=\"http://github.com/argaen/djangozone\">github</a>.</p>\r\n\r\n<p>So, this is how the blog and the repository work:</p>\r\n\r\n<h4>Branches</h4>\r\nThe repository is organized in various branches which show different elements that combine together in the master branch (which is the working version of this <a href=\"http://django.zone\">blog</a>.<br><br>\r\n\r\nExample branches:\r\n<ul>\r\n<li> <b>master</b>. Main branch. Contains the code of the current blog version.</li>\r\n<li> <b>development</b>. Branch where all commits and modifications are performed. It will be merged to master branch when a new important functionality is added.</li>\r\n<li> <b>Oauth</b>. this branch (will) shows what is needed to connect Django auth system with Oauth of various social services like Google, Facebook, Twitter, etc.</li>\r\n<li> <b>DRF</b> this branch (will) shows how to serve the data of your page as a REST API. Very useful if you want to connect your page with mobile, angularjs, famo.us and more.</li>\r\n</ul>\r\n<br>\r\n\r\n<h4>Commits</h4>\r\nEach commit will have its correspondent blog post if it is enough significative in its pertinent section/tag (oauth, drf, etc.). \r\n\r\nFor example, in the master branch, in commit 315807d05d I released this blog and you can find the related post <href=\"http://django.zone/posts/1\">here</a>. Obviously, minor modifications or bug fixes won't have a post itself but edits to the related post will be applied.\r\n<br><br>\r\n\r\n<h4>Tags</h4>\r\nTags are directly related to stable commits. Oauth branch (will) has its own tag which will be updated along with the branch when modifications are applied and bugs are fixed.\r\n<br><br>\r\n\r\n<h4>Getting started</h4>\r\n\r\nIn order to start, follow this steps:\r\n\r\n<ol>\r\n<li> Download the commit you want to work with (the one referenced in the post you are reading). <code>git clone https://github.com/argaen/djangozone.git;</code> <code>cd djangozone;</code> <code>git checkout &lt;commit number&gt;</code>\r\nUse <code>git checkout 5705de9</code> to download the scratch version to check the basics are working fine.</li>\r\n\r\n<li> Install the needed dependencies: <code>sudo pip install Django</code>. If you don't have <i>pip</i> installed, install it with your distribution package manager. <i>Debian based</i>: <code>sudo apt-get install python-pip</code>.</li>\r\n\r\n<li> Go to <i>wsgi/openshift</i> folder and execute <code>python manage.py runserver</code>. Check it is working in your browser, accessing <a href=http://127.0.0.1/:8000 target=blank>localhost</a> at port 8000. You should see a blank page if you downloaded the commit 5705de9.</li>\r\n\r\n<li> If the previous step worked, now execute <code>git checkout 315807d05d</code>. Now you should see an exact copy of the blog by the time this post was written. User and password for the admin is admin-123.\r\n</ol>\r\n\r\n", "branch": "", "published": true, "commit": "315807d05d", "slug": "hello-world-this-is-djangozone"}, "model": "contents.post", "pk": 1}, {"fields": {"published_on": "2014-06-16", "author": 1, "title": "Basic Django part I", "content": "<p>This post series is a basic introduction to Django and how to combine it with <a href=\"http://openshift.com/\">Openshift</a> in order to have an online site. Before you start reading, I recommend following the <a href=\"https://docs.djangoproject.com/en/1.6/intro/tutorial01/\" target=\"blank\">tutorial</a> that djangoproject itself provides which will be more detailed than this post.</p>\r\n\r\n<p>First of all, you need to have Django installed. You can check how to install it in the <a href=\"/posts/1#gettingstarted\">first post</a> at step 2.</p>\r\n\r\n<p>Once you have it installed, go to the folder you work on your projects, and execute <code>django-admin startproject &lt;projectname&gt;</code>. Once executed, you will find the following structure:</p>\r\n\r\n<pre>\r\nprojectname\r\n|--manage.py\r\n|--projectname\r\n   |--__init__.py\r\n   |-- settings.py\r\n   |-- urls.py\r\n   |-- wsgi.py\r\n</pre>\r\n\r\n<ul>\r\n<li><b>manage.py</b>. Management file for your project. It can synchronize your database, start the development server, start an interactive shell and more. Execute <code>python manage.py -h</code> for a full list of available commands. You can also read the <a href=\"https://docs.djangoproject.com/en/dev/ref/django-admin/\">django manage.py</a> guide.</li>\r\n<li><b>settings.py</b>. Configuration file for your project. It is a python module (so you can do whatever you want in python). It contains variables that specify installed apps in your project (explained later), where to find the database, where to find static files (css, js, etc.), and more. This file will appear in almost all the posts because it is one of the most (or the most) important files in your project.</li>\r\n<li><b>urls.py</b>. Defines the routes of your project. Basically, it links the urls with your programmed functions, called views.</li>\r\n<li><b>wsgi.py</b>. Script for project deployment.</li>\r\n</ul>\r\n\r\n<p>Okay, so now, we know more or less the basic structure of a recently created Django project. If we now execute <code>python manage.py runserver</code> we will start the development server. If we open <a target=blank href=\"http://127.0.0.1:8000\">localhost:8000</a> we will see the welcome Django page.</p>\r\n\r\n<p>Welcome page is not so cute and does not provide any functionality, lets create a new app that will allow us to write posts. To do so, cd into the directory where <i>manage.py</i> is and execute <code>python manage.py startapp posts</code>. This will create a new folder called posts with the following files within it:</p>\r\n\r\n<ul>\r\n<li><b>models.py</b>. Here you define your models using python classes. Those models are directly bind to database tables. For example, for our post model we can use the following:\r\n\r\n<pre>\r\nfrom django.db import models\r\nfrom django.contrib.auth.models import User\r\n\r\nclass Post(models.Model):\r\n    title = models.CharField(max_length=200)\r\n    published_on = models.DateField(auto_now_add=True)\r\n    published = models.BooleanField(default=False)\r\n    author = models.ForeignKey(User)\r\n    tags = models.CharField(max_length=500, blank=True, null=True)\r\n    content = models.TextField()\r\n\r\n    commit = models.CharField(max_length=30, blank=True, null=True)\r\n    branch = models.URLField(max_length=150, blank=True, null=True)\r\n    tag = models.URLField(max_length=150, blank=True, null=True)\r\n\r\n    def __unicode__(self):    #Print object's title when printing the object\r\n        return self.title\r\n\r\n    def get_absolute_url(self):  #Return the url of the object\r\n        return \"/posts/%d\" % self.id\r\n\r\n    class Meta:    #Order by published_on field (newest first)\r\n        ordering = [\"-published_on\", ]\r\n</pre>\r\n\r\n<p>Now that we got our new app created and the data model defined, we need to register it as an app of our new project. Edit the variable <i>INSTALLED_APPS</i> inside the <i>settings.py</i> file and add <i>posts</i> in the end. Save it and execute <code>python manage.py syncdb</code>. If it's the first time you execute it for your project, it will ask to create a superuser for your project. Say yes and enter the username and password. If you didn't create it the first time, execute <code>python manage.py createsuperuser</code>. Once done, it will create the table <i>posts_post</i> with all the fields you specified during model definition. Pretty easy and clear right?</p>\r\n</li>\r\n\r\n<li><b>views.py</b>. Here you define functions that will provide the data that will be shown to the user using html templates. So, for example, if we want to show a list of posts and posts individually, we will create two view functions. First will return all the posts (filtered by attribute, for example, if published is True) and second will return a Post object which will be selected from the url the client accesses.\r\n\r\n<pre>\r\nfrom django.shortcuts import render, get_object_or_404\r\n\r\nfrom models import Post\r\n\r\n\r\ndef list(request):\r\n    data = {'posts': Post.objects.filter(published=True)}\r\n\r\n    return render(request, 'posts_list.html', data)\r\n\r\ndef detail(request, pk):\r\n    data = {'post': get_object_or_404(Post, pk=pk)}\r\n\r\n    return render(request, 'posts_detail.html', data)\r\n</pre>\r\n</li>\r\n\r\n<li><b>admin.py</b>. Controls what is displayed in the admin interface about the model. Yes, Django has an admin interface by default which can be used to add, modify and remove objects. You can access it at <a href=\"http://127.0.0.1:8000/admin\">localhost:8000/admin</a> (you need your development server running). If you enter you will see that posts are not listed there. To do so, the <i>admin.py</i> file should look like this:\r\n\r\n<pre>\r\nfrom django.contrib import admin\r\nfrom models import Post\r\n\r\nadmin.site.register(Post)\r\n</pre>\r\n\r\n<p>Now you can navigate to the <a href=\"http://127.0.0.1:8000/admin\">admin interface</a> and check that the posts app appears. Try to create new posts, delete them, etc.<p>\r\n</li>\r\n\r\n</ul>\r\n\r\n<p>Okay, so now we got our defined model registered with the admin interface and we can add new Post objects and work with them. We also have two view functions to retrieve individual Posts or list them. Now, we will create our html templates to use this view functions so we can show them to our readers:</p>\r\n\r\n<ol>\r\n<li> Edit the urls.py file and add the following lines before the <code>url(r'^admin/', include(admin.site.urls)),</code> line to link /posts/ and /posts/{id} urls to our view functions:\r\n<pre>\r\n    url(r'^posts$', 'posts.views.list', name='posts_list'),\r\n    url(r'^posts/(?P&lt;pk&gt;[\\w-]+)$', 'posts.views.detail', name='posts_detail'),\r\n</pre>\r\n\r\n<p>The syntax is very easy. First arg is the regular expression for our url, second is the view function we want to call and third is a unique name for the url, this allows us to call the url from html code with the <code>{% url posts_list %}</code> line.</p>\r\n\r\n<p> If we now try to access <a target=blank href=\"http://127.0.0.1:8000/posts\">/posts</a> it will raise an error saying that the template <i>posts_list.html</i> does not exist. If you remember, in the views.py from the posts app, the return line for every view specifies which template it should use to render the data we send back to the client.</p>\r\n</li>\r\n<li> Let's create the needed templates. Create a new folder inside the posts app called <i>templates</i>. Inside it, create both the <i>posts_detail.html</i> and the <i>posts_list.html</i> files:\r\n\r\n<pre>\r\n&lt;p&gt;\r\n  &lt;h3&gt;&lt;a href=&quot;/posts/{{post.id}}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/h3&gt;\r\n  &lt;p&gt;&lt;i&gt;{{ post.published_on }}&lt;/i&gt; by {{ post.author }}&lt;/p&gt;\r\n  &lt;p&gt;{% if post.tags %}Tags: {{ post.tags }}{% endif %}&lt;/p&gt;\r\n  &lt;p&gt;{% if post.commit %}Commit: &lt;a href=&quot;https://github.com/argaen/djangozone/tree/{{ post.commit }}&quot; target=blank&gt;{{ post.commit }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n  &lt;p&gt;{% if post.branch %}Branch: &lt;a href=&quot;https://github.com/argaen/djangozone/tree/{{ post.branch }}&quot; target=blank&gt;{{ post.branch }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n  &lt;p&gt;{% if post.tag %} Tag: &lt;a href={{ post.tag }} target=blank&gt;{{ post.tag }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n&lt;/p&gt;\r\n&lt;div class=&quot;post-content&quot;&gt;\r\n  &lt;p&gt;{{ post.content|safe }}&lt;/p&gt;\r\n&lt;/div&gt;\r\n&lt;hr style=&quot;margin-bottom:40px;&quot;&gt;\r\n</pre>\r\n\r\n<pre>\r\n{% for post in posts %}\r\n  &lt;p&gt;\r\n    &lt;h3&gt;&lt;a href=&quot;/posts/{{post.id}}&quot;&gt;{{ post.title }}&lt;/a&gt;&lt;/h3&gt;\r\n    &lt;p&gt;&lt;i&gt;{{ post.published_on }}&lt;/i&gt; by {{ post.author }}&lt;/p&gt;\r\n    &lt;p&gt;{% if post.tags %}Tags: {{ post.tags }}{% endif %}&lt;/p&gt;\r\n    &lt;p&gt;{% if post.commit %}Commit: &lt;a href=&quot;https://github.com/argaen/djangozone/tree/{{ post.commit }}&quot; target=blank&gt;{{ post.commit }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n    &lt;p&gt;{% if post.branch %}Branch: &lt;a href=&quot;https://github.com/argaen/djangozone/tree/{{ post.branch }}&quot; target=blank&gt;{{ post.branch }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n    &lt;p&gt;{% if post.tag %} Tag: &lt;a href={{ post.tag }} target=blank&gt;{{ post.tag }}&lt;/a&gt;{% endif %}&lt;/p&gt;\r\n  &lt;/p&gt;\r\n  &lt;div class=&quot;post-content&quot;&gt;\r\n    &lt;p&gt;{{ post.content|safe }}&lt;/p&gt;\r\n  &lt;/div&gt;\r\n  &lt;hr style=&quot;margin-bottom:40px;&quot;&gt;\r\n{% endfor %}\r\n</pre>\r\n\r\n<p>The syntax for the template rendering is very similar to jinja and angularjs. If you refresh now the browser, you will see your posts in a very ugly format (in next post I'll show briefly how to connect templates with css and js files). If it still shows the same error, reload the server. If you see nothing, create some posts using the admin interface and make sure you've marked the published tick!.</p>\r\n</li>\r\n</ol>\r\n\r\n\r\n<p> That's all for this post, next post will refactor the code to follow an structure that <a href=\"http://openshift.com/\" target=blank>Openshift</a> can understand so we can push our code to the service and have it working online! The last post (3rd) will also add some styling among other things in order to catch up the status of the blog you are seeing right now.</p>", "branch": "", "published": true, "commit": "5705de9", "slug": "basic-django-part-i"}, "model": "contents.post", "pk": 2}, {"fields": {"published_on": "2014-06-18", "author": 1, "title": "Basic Django part II (Openshift refactor)", "content": "<p>This post is a continuation of the <a target=blank href=\"/posts/2\">previous one</a>. In this one, you will refactor your basic Django project to support <a href=\"http://openshift.com\" target=blank>Openshift</a> project structure. Doing this, you will be able to have an online site working on their gears.</p>\r\n<p>Let's recall the project structure we got till now:</p>\r\n<pre>\r\nprojectname\r\n|--manage.py\r\n|--projectname\r\n   |--__init__.py\r\n   |-- settings.py\r\n   |-- urls.py\r\n   |-- wsgi.py\r\n|--posts\r\n   |--__init__.py\r\n   |--admin.py\r\n   |--models.py\r\n   |--tests.py\r\n   |--views.py\r\n   |--templates\r\n      |--posts_detail.html\r\n      |--posts_list.html\r\n|--db.sqlite3\r\n</pre>\r\n\r\n<p>Before you start, create a new <a href=https://www.openshift.com/app/account/new target=blank>Openshift</a> account and once you are registered, create a new application selecting the Django application type. I usually select python2.7 in the cartridges section. Click in <i>create application</i> (this may take a while). Once finished, click on <i>Yes, help me get started</i> and upload your public ssh key. If you don't have one, execute <code>ssh-keygen</code> and accept all default values. When you finish, copy the contents of <i>~/.ssh/id_rsa.pub</i> and save. Clone the project following the steps they show you (<code>git clone</code>). Once downloaded, cd into the project folder and execute <code>rm *</code>.</p> \r\n\r\n<p>So, now yes, let's start:</p>\r\n\r\n<ol>\r\n\r\n<li>Create the following directory structure inside the downloaded folder of your Openshift app:\r\n<pre>\r\n|--projectname (this folder is the project folder you've just cloned with git, it is already created. I'll call it djangozone from now on)\r\n   |--setup.py\r\n   |--wsgi.py\r\n   |--wsgi\r\n      |--static\r\n      |--djangozone\r\n         |--__init__.py\r\n</pre>\r\n </li>\r\n\r\n<li>Copy the files <i>manage.py</i>, <i>settings.py</i>, <i>urls.py</i> and <i>db.sqlite3</i> and the <i>posts</i> app to <i>djangozone/wsgi/djangozone</i> folder of the new project.</li>\r\n\r\n<li>In <i>settings.py</i> remove the line that sets the <i>WSGI_APPLICATION</i> variable. Change the \"ROOT_URLCONF = projectname.urls\" to \"ROOT_URLCONF = urls\".</li>\r\n\r\n<li>In <i>manage.py</i> change the line <code>os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"projectname.settings\")</code> to <code>os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"settings\")</code></li>\r\n\r\n<li>Edit the <i>djangozone/wsgi.py</i> and set the content equal to the file you can find in <a href=\"https://github.com/argaen/djangozone/blob/development/wsgi.py\" target=blank>github</a></li>\r\n\r\n<li>Edit the <i>djangozone/setup.py</i> and set the content equal to the file you can find in <a href=\"https://github.com/argaen/djangozone/blob/development/setup.py\" target=blank>github</a></li>\r\n\r\n<li>Edit the <i>settings.py</i> and add the line <code>STATIC_ROOT = os.path.join(BASE_DIR, '../static')</code> under the <i>STATIC_URL</i> variable. Also change the line <i>BASE_DIR = os.path.dirname(os.path.dirname(__file__))</i> to <i>BASE_DIR = os.path.dirname(os.path.realpath(__file__)).</i></li>\r\n\r\n<li>Also, in <i>settings.py</i> file, remove the <i>DEBUG=True</i> and <i>ALLOWED_HOSTS=[]</i> and put this (we don't want DEBUG mode in production):\r\n<pre>\r\nON_OPENSHIFT = False\r\nif 'OPENSHIFT_REPO_DIR' in os.environ:\r\n    ON_OPENSHIFT = True\r\n\r\nif ON_OPENSHIFT:\r\n    DEBUG = False\r\n    ALLOWED_HOSTS = ['*']\r\nelse:\r\n    DEBUG = True\r\n    ALLOWED_HOSTS = []\r\n</pre>\r\n</li>\r\n\r\n</ol>\r\n\r\n<p>Time to upload the project to <a href=\"http://openshift.com\">Openshift</a>!. Let's apply the changes and upload them. Do <code>git add -A .;git commit -m \"Initial commit\";git push</code> from the root of the project and let Openshift do the magic of deploying your project automatically! Once uploaded, access the url of your application (applications section in the Openshift page). It will show a page not found error, this is because we have no welcome page, access directly to /posts and it should show a blank page (if you had a post already created from part 1 post, it should appear because you copied the db.sqlite3 file). So, now it's time to create a new post by accessing the /admin page. You will see that the admin page is so ugly, this is because the static files where not collected (now we are running our app using a web server which does not know where to find those files, we have to place them all in the <i>djangozone/wsgi/static</i> folder). To do so, we can use the Openshift <a target=blank href=\"https://www.openshift.com/developers/deploying-and-building-applications#build\">action hooks</a> to collect all the files automatically every time we do a deploy:</p>\r\n\r\n<ol>\r\n<li>If you cloned the git repo from your Openshift application, you should have a <i>djangozone/.openshift/action_hooks</i> folder. cd into it.</li>\r\n<li>Create a file called <i>deploy</i> with the following inside:\r\n<pre>\r\n#!/bin/bash\r\n\r\necho \"Executing 'python $OPENSHIFT_REPO_DIR/wsgi/djangozone/manage.py collectstatic --noinput'\"\r\npython \"$OPENSHIFT_REPO_DIR\"wsgi/djangozone/manage.py collectstatic --noinput\r\n</pre>\r\n</li>\r\n<li> Do <code>git add -A .;git commit -m \"Static files configuration\";git push</code> and when it finishes, you should see the same page as when running in local.</li>\r\n\r\n</ol>\r\n\r\n<p>Right now, you have the same app running in Openshift online and in your local environment. You can try to add new posts and read them in your online instance.</p>\r\n\r\n<p>Still, the site has no styling, soon I'll post how templates work and how to load external css and js files. If you can't wait, check the files under <i>posts/templates</i> and this <a target=blank href=\"https://docs.djangoproject.com/en/dev/howto/static-files/\">page</a>.</p>\r\n\r\n<p>We are not in the same version that <a href=http://django.zone>django.zone</a> is running at yet. In the next post, I will show how templates, urls and some configuration settings work in order to catch up the current version!</p>\r\n\r\n\r\n\r\n\r\n\r\n\r\n", "branch": "", "published": true, "commit": "0b231a8", "slug": "basic-django-part-ii-openshift-refactor"}, "model": "contents.post", "pk": 3}, {"fields": {"published_on": "2014-06-25", "author": 1, "title": "Basic Django part III", "content": "<p>This post is a continuation of the <a target=blank href=\"/posts/3\">previous one</a>. In this one, we will a add some styling to our using django templates, static files and <a href=\"http://getbootstrap.com/\" target=blank>twitter bootstrap</a> and how to use a decent database backend (postgresql) in Openshift to save our posts. We will also do some minor modifications to make our code cleaner.</p>\r\n\r\n<h4>Templates</h4>\r\n\r\n<p>We will start by creating an app called common to save all the stuff not related to our content apps. Do <code>python manage.py startapp common</code> and register it in the settings file (<i>INSTALLED_APPS</i>) variable. Create a <i>templates</i> folder within the <i>common</i> app and the files <i>base.html</i> and <i>about.html</i> (yeah, we are creating an about page) within this folder. Copy the contents you can find in the github <a href=\"https://github.com/argaen/djangozone/blob/development/wsgi/openshift/common/templates/base.html\" target=blank>base.html</a> and <a href=\"https://github.com/argaen/djangozone/blob/development/wsgi/openshift/common/templates/about.html\">about.html</a> files to the files you've just created.</p>\r\n\r\n<p>If you open the <i>base.html</i> file, you will see that it looks like a common html (just FYI, I will not explain html, css and so on...) file except for some lines like <code>{% load staticfiles %}</code>. These lines, are rendered by the Django template system. For example, this one asks to load the <i>staticfiles</i> module, once you've loadded this module, you can ask for static files as you can see in lines 60-63 (i.e. {% static \"img/logos/django.png\" %}) were we load the icons of the <i>Powered by</i> section. You can also find the <code>{% block content %}</code> at line 54. This allows us to define blocks for other templates that will inherit from this one. To understand this, let's open the <i>about.html</i> file.</p>\r\n\r\n<p>In the <i>about.html</i> file you can find the <code>{% extends 'base.html' %}</code> line that specifies as you can guess, that this template is inheriting from <i>base.html</i>. Because of that, we can overwrite the blocks specified in that file:</p>\r\n\r\n<pre>\r\n{% block content %}\r\n&lt;Content goes here&gt;\r\n{% endblock %}\r\n</pre>\r\n\r\n<p>With that, we avoid to rewrite the common parts of the template (such as footer, header, etc.).</p>\r\n\r\n<p>Let's check how this looks like. Open the <i>urls.py</i> file and write the line <code>url(r'^about/$', 'common.views.about', name='about'),</code>. Also, in the <i>common/views.py</i> file, and write the following:</p>\r\n<pre>\r\nfrom django.shortcuts import render_to_response\r\n \r\ndef about(request):\r\n    return render_to_response('about.html')\r\n</pre>\r\n\r\n<p>If you now try to access <a href=http://localhost:8000/about>/about</a> and you will see that something appears. All images and some styling are missing. This is because we don't the required static files. Although, bootstrap styles are correctly loaded because we are using a <i>cdn</i>. We are done explaining templates, modify the templates of the posts app to inherit from the <i>base.html</i> file. You can find the original files in <a target=blank href=https://github.com/argaen/djangozone/tree/development/wsgi/openshift/posts/templates>github</a>. Now that we got our templates, it's time to load our static content correctly.</p>\r\n\r\n<h4>Static Files</h4>\r\n\r\n<p>Static files are those files which are static (O RLY?) like images, css spreadsheets, javascripts and so on. By default, to load those files, in debug mode Django looks within a folder called <i>static</i> of all the installed apps of your project. If you now specify <code>DEBUG=False</code> in your <i>settings.py</i> file and try to access to the <a href=\"http://localhost:8000/admin\">admin</a> page, you will see that all styles are missing. To make it work, you need to execute <code>python manage.py collectstatic</code> you will see that a folder called <i>admin</i> appears within <i>djangozone/wsgi/static</i>. The same applies for our apps. Let's create the <i>static</i> folder for the <i>common</i> app. You can download all the contents from <a target=blank href=\"https://github.com/argaen/djangozone/tree/development/wsgi/openshift/common/static\">github</a>. Set <code>DEBUG=True</code> again in your <i>settings</i> file and reload your site. <i>Voil\u00e0!</i> now our blog starts looking not so ugly at all. When pushing our project to Openshift, it will work in deploy mode but collectstatic will be executed automatically because we defined the deploy action hook in previous post so you don't have to worry about static files anymore (as long as you place static files inside the static folder of your pertinent apps).</p>\r\n\r\n\r\n<h4>Urls</h4>\r\n\r\n<p>We want to have an organized project. The <i>urls</i> can be distributed among different apps (more or less like static files, templates). In the main <i>urls.py</i> file we have urls defined for our posts app and this is not correct at all. Create a file called <i>urls.py</i> within the <i>posts</i> app with this content:</p>\r\n<pre>\r\nfrom django.conf.urls import patterns, url\r\n\r\nurlpatterns = patterns(\r\n   'posts.view',\r\n   url(r'^$', 'list', name='posts_list'),\r\n   url(r'^(?P<pk>[\\w-]+)$', 'detail', name='posts_detail'),\r\n)\r\n</pre>\r\n\r\n<p>In the main <i>urls.py</i> file, remove the lines related to <i>posts</i> app and add these lines:</p>\r\n<pre>\r\nurl(r'^$', 'posts.views.list', name='posts_list'),\r\nurl(r'^posts/', include('posts.urls')),\r\n</pre>\r\n\r\n<p>With the first, we specify home page to display all the posts. With the second, we include the urls defined in the <i>posts</i> app.\r\n\r\n<h4>Postgres and Openshift</h4>\r\n\r\nSqlite isn't a database for production. To use Postgres, we need first to create the instance (cartridge) in our Openshift. To do so, access to your <a target=blank href=https://openshift.redhat.com/app/console/applications>applications</a> and click in your application. Click on 'add postgresql 9.2'. Once completed, it will display your acess data but don't worry, we don't need it. Open the <i>settings</i> file and remove the <i>DATABASES</i> dictionary and write these lines:\r\n\r\n<pre>\r\nif ON_OPENSHIFT:\r\n    url = urlparse.urlparse(os.environ.get('OPENSHIFT_POSTGRESQL_DB_URL'))\r\n    DATABASES = {\r\n        'default': {\r\n            'ENGINE': 'django.db.backends.postgresql_psycopg2',\r\n            'NAME': os.environ['OPENSHIFT_APP_NAME'],\r\n            'USER': url.username,\r\n            'PASSWORD': url.password,\r\n            'HOST': url.hostname,\r\n            'PORT': url.port,\r\n            }\r\n        }\r\n\r\nelse:\r\n    DATABASES = {\r\n        'default': {\r\n            'ENGINE': 'django.db.backends.sqlite3',\r\n            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),\r\n        }\r\n    }\r\n</pre>\r\n\r\nWrite <code>import urlparse</code> at the top of <i>settings.py</i> file. We are ready to deploy our blog! Add your changes, commit and push!", "branch": "", "published": true, "commit": "315807d05d", "slug": "basic-django-part-iii"}, "model": "contents.post", "pk": 4}, {"fields": {"published_on": "2014-07-02", "author": 1, "title": "Using django-taggit", "content": "<p>In this post I will show how to use tags correctly for our posts. Taggit allows to search among our posts by tag, search posts with similar tags and more. You can check its documentation <a href=\"http://django-taggit.readthedocs.org/en/latest/\">here</a>.</p>\r\n\r\n<p>Let's do this. Install the package with <code>pip install django-taggit</code> and register it in <i>INSTALLED_APPS</i> inside your <i>settings.py</i> file (app name is <i>taggit</i>. Once done, run <code>python manage.py syncdb</code> to create the tag tables in your database. Now, for each model you want to add a tag (posts in our case), create a new field like this: <code>tags = TaggableManager(blank=True)</code>. You can import <i>TaggableManager</i> with <code>from taggit.managers import TaggableManager</code>.</p>\r\n\r\n<p>After this, we can go to our <a target=blank href=\"http://localhost:8000/admin\">admin</a> interface, edit a post and add tags as comma separated words. After saving, if we try to refresh, it will display the object instance rather than the tags. This is because in the posts template we have <code>{{post.tags}}</code>. Write these lines to display the tags:</p>\r\n\r\n<pre>\r\n      {% if post.tags %}&lt;p&gt;Tags: \r\n        {% for tag in post.tags.all %}\r\n        &lt;a href=\"/posts/tag/{{ tag }}\"&gt;{{tag}}&lt;/a&gt;\r\n        {% if not forloop.last %},{% endif%}\r\n        {% endfor %}\r\n      &lt;/p&gt;{% endif %}\r\n</pre>\r\n\r\n<p>We also need to add a line to the <i>urls.py</i> for our posts app: <code>url(r'^tag/(?P<tag>\\w+)$', 'tags', name='posts_tags'),</code> and create a new view in <i>views.py</i> to display the posts with the given tags:</p>\r\n\r\n<pre>\r\ndef tags(request, tag):\r\n    data = {'posts': Post.objects.filter(tags__name__in=[tag])}\r\n\r\n    return render(request, 'posts_list.html', data)\r\n</pre>\r\n\r\n\r\n<p>It is also interesting when reading a post, to display the ones with similar tags. We can do this so easily. To do so, we need to modify our detail template by adding these lines:</p>\r\n<pre>\r\n  {% if post.tags.similar_objects %}\r\n    Similar: \r\n    {% for s in post.tags.similar_objects|slice:\":3\" %}\r\n      &lt;a href={% url 'posts_detail' s.id %}&gt;{{s}}&lt;/a&gt;\r\n    {% if not forloop.last %},{% endif%}\r\n    {% endfor %}\r\n  {% endif %}\r\n</pre>\r\n\r\n<p> With this, code, we are showing the three most similar (in tags) posts being the first the most similar one.</p> ", "branch": "", "published": true, "commit": "bb1207736e", "slug": "using-django-taggit"}, "model": "contents.post", "pk": 5}, {"fields": {"published_on": "2014-07-09", "author": 1, "title": "Adding disqus comments to your posts", "content": "<h4>Basic configuration</h4>\r\n\r\n<p>In previous versions, Django provided a comments framework in the <i>contrib</i> packages but now is deprecated so I will be using <i>disqus</i>. To integrate it with Django I could use the <i>django-disqus</i> but I won't. I'll integrate it with raw code because in the next post I'll write about templatetags which is what <i>django-disqus</i> uses so then, you can move to use this package understanding what you are really doing.</p>\r\n\r\n<p>First of all, we need to create a disqus <a href=\"https://disqus.com/profile/signup/?next=https%3A//disqus.com/\" target=blank>account</a>. Once created, <a href=http://disqus.com/admin/create/ target=blank>register</a> a new app. When you finish the registration, choose the \"Universal Code\" platform choice and paste the code it displays where you want the comments to appear. In my case, I'll use the <i>posts_detail.html</i> template.</p>\r\n\r\n<pre>\r\n&lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;\r\n&lt;script type=&quot;text/javascript&quot;&gt;\r\n/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */\r\nvar disqus_shortname = \"SHORT_NAME\"; // required: replace example with your forum shortname\r\n/* * * DON'T EDIT BELOW THIS LINE * * */\r\n(function() {<br/>            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\r\ndsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';<br/>            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\r\n})();\r\n&lt;/script&gt;\r\n&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;http://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;\r\n&lt;a href=&quot;http://disqus.com&quot; class=&quot;dsq-brlink&quot;&gt;comments powered by &lt;span class=&quot;logo-disqus&quot;&gt;Disqus&lt;/span&gt;&lt;/a&gt;\r\n</pre>\r\n\r\n<p>Replace SHORT_NAME with your disqus app name you've just created. If you now refresh your page, it should appear a form that users can use to comment.</p>\r\n\r\n<p>Within the <a href=http://disqus.com/admin target=blank>disqus admin</a> page you can perform further configurations for comment moderation, control who can comment, minor template modifications and more.</p>\r\n\r\n<p>That's all, we got now functional comments for our posts. In next section I will show <a href=recentcomments>how to create a section that shows recent comments</a>.</p>\r\n\r\n<h4 id=recentcomments>Recent Comments</h4>\r\n\r\nTo show recent comments, disqus also provides a javascript code similar to the one used to retrieve comments for a post. If you want to display recent comments, you can use this code:\r\n\r\n<pre>\r\n&lt;div class=&quot;panel panel-primary&quot;&gt;\r\n&lt;div class=&quot;panel-heading&quot;&gt;\r\n&lt;h4&gt;Recent Comments&lt;/h4&gt;\r\n&lt;/div&gt;<br/>\r\n&lt;div id=&quot;RecentComments&quot; class=&quot;dsq-widget panel-body&quot;&gt;\r\n&lt;script type=&quot;text/javascript&quot; src=&quot;http://djangozone.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_mods=0&amp;hide_avatars=0&amp;avatar_size=32&amp;excerpt_length=100&quot;&gt;&lt;/script&gt;\r\n&lt;/div&gt;\r\n&lt;/div&gt;\r\n</pre>\r\n\r\n<p>The following arguments allow you to customize the data that is shown:</p>\r\n\r\n<ul>\r\n<li><b>num_items</b>: Number of comments to return.</li>\r\n<li><b>hide_mods</b>: If 1, hide admin comments.</li>\r\n<li><b>hide_avatars</b>: If 1, hide user avatars.</li>\r\n<li><b>avatar_size</b>: Size of the avatar in px.</li>\r\n<li><b>excerpt_length</b>: Max length of the comments being displayed. They are truncated in chars.</li>\r\n</ul>\r\n\r\n\r\n", "branch": "", "published": true, "commit": "a203346e52", "slug": "adding-disqus-comments-to-your-posts"}, "model": "contents.post", "pk": 6}, {"fields": {"published_on": "2014-07-26", "author": 1, "title": "Giving format to text inputs with django-tinymce", "content": "Intro for urls, black text, etc.\r\n\r\nInstall django-tinymce and install also tinymce is it necessary? (check alternative method for openshift). Add tinymce to installed apps. Add the url     url(r'^tinymce/', include('tinymce.urls')), to urls.py. Edit the admin form and then use the custom config in settings.py.\r\n\r\n\r\nMore info: http://django-tinymce.readthedocs.org/en/latest/installation.html", "branch": "", "published": false, "commit": "", "slug": "giving-format-text-inputs-django-tinymce"}, "model": "contents.post", "pk": 7}, {"fields": {"published_on": "2014-07-30", "author": 1, "title": "Django templatetags", "content": "<p>Template tags are the core of Django templates providing well-known coding functionalities like loops (\"for\" tag), conditions (\"if\" tag) and more. You can check the full list in the <a href=\"https://docs.djangoproject.com/en/dev/ref/templates/builtins/\">djangoproject</a> page. While they are enough powerful to provide all the basic functionality you need in your projects, sometimes, just to follow the principle of DRY, it is worth it to implement some custom template tags.</p>\r\n\r\n<p>Let's see a very basic example. Here in DjangoZone we got a basic <a href=\"http://django.zone/posts/basic-django-part-i\">Post model</a> that supports <a href=\"http://django.zone/posts/using-django-taggit\">tags</a> and <a href=\"http://django.zone/posts/adding-disqus-comments-to-your-posts\">disqus comments</a>. Now, we want people navigating and looking for cool Django tutorials to find our awesome posts. To do so, we will use the html meta-keyword in order to categorize our posts and make them appear in the right time. </p>\r\n\r\n<p>Why do we need templatetags then? Right now, we can obtain our post tags accessing the <code>{{ post.tags.all }}</code> variable from our <a href=\"https://github.com/argaen/djangozone/blob/master/wsgi/djangozone/posts/templates/posts_detail.html#L10\">posts_detail.html</a> template. You can see that we loop through all the tags creating an href element for each one. If we want to use post tags as our keywords, we will have to write again the loop to show all them as a comma separated list. That's the opportunity we seek to write a new tag.</p>\r\n\r\n<p>First, we both need the comma separated list and the list of href elements so, our template tag is going to have an argument to distinguish which functionality we need. Let's create it:</p>\r\n\r\n<ul>\r\n<li>First, create a \"templatetags\" folder within the posts app and cd into it. This is where Django looks for by default.</li>\r\n<li>Don't forget to create a \"__init__.py\" file so the folder is identified as a python module folder.</li>\r\n<li>Create the \"posts_tags.py\" file and write the following:</li>\r\n<pre>\r\nfrom django import template\r\n\r\nimport os\r\n\r\nregister = template.Library()\r\n\r\n@register.simple_tag                    #register this function as a callable tag\r\ndef get_tags(tags, url=None):\r\n    ret_tags = []\r\n    for tag in tags:\r\n        head = \"&lt;a href=%s&gt;#\" % os.path.join(url, tag) if url else ''\r\n        tail = \"&lt;/a&gt;\" if url else ''\r\n        ret_tags.append(head+str(tag)+tail)\r\n    return ', '.join(ret_tags)\r\n</pre>\r\n</li>\r\n<li> And now, in the template load the tag with <code>{% load posts_tags %}</code> and then call it where you need with <code>{% get_tags post.tags.names \"/posts/tags\" %}</code> if you need an href list where each link points to \"/posts/tags/&lt;tag_name&gt;\" or <code>{% get_tags post.tags.names %}</code> if you want the comma separated tags list.</li>\r\n<li> After reloading the page, you should see the meta keywords if you open the source code of the html and the tag list for the post should still be there. </li>\r\n</ul>\r\n\r\n<p>If you check the templatetags file in <a href=\"https://github.com/argaen/djangozone/blob/development/wsgi/djangozone/posts/templatetags/posts_tags.py\">github</a>, you can also check the function to retrieve the latest X posts where X is a parameter indicating how many posts you want to retrieve.</p>\r\n", "branch": "", "published": true, "commit": "2956735154", "slug": "django-templatetags"}, "model": "contents.post", "pk": 8}]
